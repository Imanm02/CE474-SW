\section*{جواب سوال ۴}

\section*{مقایسه مفاهیم از لحاظ ریزدانگی و درشت‌دانگی}

در حوزه آزمون نرم‌افزار، مفاهیم مختلفی وجود دارند که از لحاظ سطح بررسی و تحلیل (ریزدانگی و درشت‌دانگی) با یکدیگر متفاوت هستند. این تفاوت‌ها در معماری‌های 
\lr{Microservices}
و
\lr{Monolithic}
به‌خوبی قابل مشاهده است.

\begin{itemize}
	\item \lr{Unit Testing}: در معماری \lr{Microservices} ، آزمون واحد به دلیل تقسیم‌بندی و ماژولاریتی بالا، اهمیت بیشتری پیدا می‌کند. در معماری \lr{Monolithic} ، آزمون واحد ممکن است به دلیل وابستگی‌های متقابل درونی پیچیده‌تر باشد.
	
	\item \lr{Integration Testing}: در \lr{Microservices} ، آزمون ادغام عمدتاً بر روی تعاملات بین سرویس‌ها تمرکز دارد، در حالی که در \lr{Monolithic} ، بر روی تعاملات بین مؤلفه‌ها در یک سیستم واحد تمرکز می‌کند.
	
	\item \lr{E2E Testing} و \lr{Acceptance Testing}: هر دو در معماری‌های \lr{Microservices} و \lr{Monolithic} اهمیت دارند، اما در \lr{Microservices} ، تست انتها به انتها ممکن است شامل تعاملات پیچیده‌تر و بیشتری بین سرویس‌ها باشد.
	
	\item \lr{Black Box} و \lr{White Box Testing} : این دو نوع آزمون از نظر دانش آزمون‌دهنده از کد مورد بررسی قرار می‌گیرند و در هر دو معماری کاربرد دارند، اما در 
\lr{Microservices}
 ، آزمون جعبه سفید ممکن است بر روی ماژولاریتی و API ها تمرکز بیشتری داشته باشد.
	
	\item \lr{Happy Path Testing}: این روش آزمون بر سناریوهایی تمرکز دارد که در آنها همه چیز طبق انتظار پیش می‌رود. این نوع آزمون در هر دو معماری مهم است، اما در معماری \lr{Microservices}
	، توجه خاصی به تضمین اینکه تعاملات بین سرویس‌ها به خوبی کار می‌کنند، نیاز دارد.

	\item \lr{Exceptional Testing}: آزمون استثنایی به بررسی نحوه رفتار نرم‌افزار در شرایط خطا می‌پردازد. در 
	\lr{Microservices}
	، اهمیت دارد که چگونگی مدیریت خطاها و استثناها در سرویس‌های مختلف و تعاملات بین آنها بررسی شود. در معماری 
	\lr{Monolithic}
	، بررسی چگونگی مدیریت خطاهای داخلی و وابستگی‌ها مهم است.

	\item \lr{Mocking}: این تکنیک به شبیه‌سازی بخش‌هایی از سیستم برای آزمون بدون نیاز به وابستگی‌های واقعی اشاره دارد. در معماری 
	\lr{Microservices}
	،
	\lr{Mocking}
	برای شبیه‌سازی سرویس‌هایی که یک سرویس به آنها وابسته است، کاربرد دارد. در معماری 
	\lr{Monolithic}
	،
	\lr{Mocking}
	می‌تواند برای شبیه‌سازی پایگاه داده‌ها یا سایر مؤلفه‌های داخلی استفاده شود.

	\item \lr{TDD (Test-Driven Development)}: این رویکرد که در آن تست‌ها قبل از نوشتن کد نوشته می‌شوند، در هر دو معماری کاربردی است. در 
	\lr{Microservices}
	، 
	\lr{TDD}
	می‌تواند به تضمین اینکه هر سرویس به صورت مستقل قابل آزمون و توسعه باشد کمک کند. در معماری 
	\lr{Monolithic}
	،
	\lr{TDD}
	به اطمینان از اینکه تغییرات در یک بخش از سیستم باعث ایجاد مشکل در بخش‌های دیگر نمی‌شود، کمک می‌کند.

\end{itemize}

با توجه به این توضیحات، می‌توان دید که چگونه هر یک از این مفاهیم آزمون نرم‌افزار، با توجه به سطح ریزدانگی و درشت‌دانگی، در معماری‌های Microservices و Monolithic کاربرد دارند. استفاده از این تکنیک‌ها و رویکردها در معماری‌های مختلف نه تنها به افزایش کیفیت و استحکام نرم‌افزار کمک می‌کند، بلکه اطمینان حاصل می‌شود که نرم‌افزار در برابر شرایط و سناریوهای مختلف به درستی عمل می‌کند.

در معماری Microservices ، تمرکز بر تست‌های مستقل برای هر سرویس و نیز بررسی تعاملات و ادغام آن‌ها با یکدیگر، اهمیت زیادی دارد. این موضوع باعث می‌شود که
\lr{Mocking}
و 
\lr{Integration Testing}
به ابزارهای حیاتی برای تضمین عملکرد صحیح سیستم در سطح کلی تبدیل شوند. از سوی دیگر، در معماری Monolithic ، که اجزای مختلف نرم‌افزار به شدت با یکدیگر ادغام شده‌اند، آزمون‌های واحد و تست‌های ادغام داخلی برای شناسایی و حل مشکلات قبل از اینکه آن‌ها تاثیر گسترده‌ای بر سیستم داشته باشند، بسیار حیاتی هستند.

\lr{Happy Path Testing}
و
\lr{Exceptional Testing}
نیز در هر دو معماری نقش مهمی دارند. این تست‌ها به تیم‌های توسعه اجازه می‌دهند تا از پایداری و قابلیت اطمینان نرم‌افزار در شرایط مختلف اطمینان حاصل کنند.
\lr{Happy Path Testing}
 بررسی می‌کند که نرم‌افزار در شرایط ایده‌آل چگونه عمل می‌کند، در حالی که
\lr{Exceptional Testing}
  به چالش کشیدن نرم‌افزار در شرایط استثنایی و خطاها را بررسی می‌کند.

\lr{TDD (Test-Driven Development)}
به عنوان یک فلسفه و رویکرد در توسعه نرم‌افزار، به توسعه‌دهندگان کمک می‌کند تا با نوشتن تست‌ها قبل از کد، از ابتدا تمرکز خود را بر کیفیت و عملکرد متمرکز کنند. این رویکرد در هر دو معماری می‌تواند به ایجاد کدی منجر شود که نه تنها مطابق با نیازمندی‌ها است، بلکه از ابتدا برای آزمون و نگهداری آسان‌تر طراحی شده است.

در نهایت، انتخاب و به‌کارگیری این مفاهیم آزمون نرم‌افزار، بسته به اهداف خاص پروژه، معماری انتخابی، و محدودیت‌های موجود متفاوت خواهد بود. تفاهم و اجرای دقیق این تکنیک‌ها در معماری‌های Microservices و Monolithic به توسعه‌دهندگان کمک می‌کند تا با اطمینان بیشتری به سمت تولید نرم‌افزارهایی با کیفیت بالا و قابل اطمینان حرکت کنند.

\section*{توضیح مفاهیم با مثال}

\subsection*{Unit Testing}
در
\lr{Microservices}
تست یک سرویس احراز هویت می‌تواند نمونه‌ای از آزمون واحد باشد. در 
\lr{Monolithic }
تست یک تابع محاسبه مالیات مثالی از آزمون واحد است.

\subsection*{\lr{Integration Testing}}
در 
\lr{Microservices}
آزمون ادغام می‌تواند شامل تست ارتباط بین سرویس احراز هویت و سرویس سفارشات باشد. در 
\lr{Monolithic}
ممکن است تست نحوه تعامل بخش‌های مختلف سیستم مانند ماژول کاربران و ماژول محصولات باشد.

\subsection*{\lr{E2E Testing}}
در هر دو معماری، آزمون انتها به انتها می‌تواند شامل تست کامل فرآیند خرید، از جستجوی محصول تا تکمیل سفارش باشد.

\subsection*{Acceptance Testing}
آزمون پذیرش در
\lr{Microservices}
 ممکن است بر روی قابلیت‌های کلی سیستم تمرکز کند، در حالی که در Monolithic ممکن است شامل بررسی انطباق کارکردهای سیستم با نیازهای کسب‌وکار باشد.

\subsection*{\lr{Black Box Testing} و \lr{White Box Testing}}
در
\lr{Microservices}
 آزمون جعبه سیاه می‌تواند شامل تست API ها بدون دانستن جزئیات پیاده‌سازی باشد. آزمون جعبه سفید می‌تواند بر روی تست پیاده‌سازی داخلی یک سرویس خاص تمرکز کند.

\subsection*{\lr{Happy Path Testing}}
تست مسیر خوشبختی
\lr{(Happy Path Testing)}
به آزمون موفقیت‌آمیز فرآیندهای اصلی سیستم بدون هیچ خطایی اشاره دارد. به عنوان مثال، در یک سیستم خرید آنلاین، تست فرآیند خرید از انتخاب محصول تا پرداخت بدون مواجهه باهیچ خطا یا مشکلی نمونه‌ای از این نوع تست است. این آزمون اطمینان می‌دهد که مسیرهای اصلی و مورد انتظار سیستم به طور صحیح کار می‌کنند.

\subsection*{\lr{Exceptional Testing}}
آزمون استثنایی
\lr{(Exceptional Testing)}
 به تست نرم‌افزار برای مدیریت خطاها و استثناها می‌پردازد. این آزمون بررسی می‌کند که آیا نرم‌افزار می‌تواند به طور مؤثر از پس موقعیت‌های غیرمنتظره برآید یا خیر. به عنوان مثال، وارد کردن داده‌های نامعتبر توسط کاربر و بررسی نحوه رفتار سیستم در این شرایط.

\subsection*{\lr{Mocking}}
شبیه‌سازی یا 
\lr{Mocking}
به تکنیکی در آزمون نرم‌افزار اشاره دارد که در آن اجزای سیستم که آزمون وابستگی به آن‌ها دارد (مانند پایگاه داده‌ها، سرویس‌های وب یا سایر ماژول‌ها) به وسیله‌ی اشیاء جعلی
\lr{(mock objects)}
جایگزین می‌شوند. این کار امکان آزمون بخش‌های خاصی از کد را بدون نیاز به وابستگی‌های خارجی یا پیچیده فراهم می‌آورد. به عنوان مثال، شبیه‌سازی یک سرویس پرداخت برای تست بدون نیاز به اتصال واقعی به سرویس پرداخت.

\subsection*{\lr{TDD (Test-Driven Development)}}
توسعه محور تست
\lr{(TDD)}
 یک روش توسعه نرم‌افزار است که در آن تست‌ها قبل از نوشتن کد اصلی نوشته می‌شوند. این رویکرد توسعه را به سمتی هدایت می‌کند که از ابتدا مطابق با الزامات تست باشد.
\lr{TDD}
 به تضمین کیفیت کد کمک می‌کند و اطمینان می‌دهد که نیازمندی‌ها به درستی پیاده‌سازی شوند. به عنوان مثال، نوشتن یک تست برای تابع محاسبه مجموع قبل از اینکه خود تابع پیاده‌سازی شود.

\section*{نتیجه‌گیری}
معماری‌های
\lr{Microservices}
و
\lr{Monolithic}
هر کدام چالش‌ها و مزایای خاص خود را در حوزه آزمون نرم‌افزار دارند. درک و اجرای صحیح مفاهیم آزمون نرم‌افزار، از جمله
\lr{Unit Testing}
،
\lr{Integration Testing}
،
\lr{E2E Testing}
،
\lr{Acceptance Testing}
،
\lr{Black Box}
و
\lr{White Box Testing}
،
\lr{Happy Path Testing}
،
\lr{Exceptional Testing}
،
\lr{Mocking}
و 
\lr{(TDD)}
می‌تواند به بهبود کیفیت نرم‌افزار و افزایش رضایتمندی کاربران کمک کند. استفاده از تکنیک‌های آزمون مناسب برای هر معماری خاص از اهمیت بالایی برخوردار است. در معماری Microservices، توجه به تست‌های ادغام و E2E برای اطمینان از ارتباط صحیح بین سرویس‌ها ضروری است، در حالی که در معماری Monolithic، تمرکز بر آزمون‌های واحد و ادغام درونی اجزا می‌تواند به حفظ کیفیت کمک کند.

\lr{(Mocking)}
و
\lr{(TDD)}
نیز رویکردهای مهمی در هر دو معماری هستند که به تسریع توسعه و اطمینان از پایداری نرم‌افزار کمک می‌کنند. با به کارگیری این استراتژی‌ها، توسعه‌دهندگان می‌توانند تضمین کنند که نرم‌افزار در برابر تغییرات آینده مقاوم است و به راحتی قابل نگهداری و توسعه خواهد بود.

در نهایت، انتخاب استراتژی‌ها و تکنیک‌های آزمون مناسب، بستگی به اهداف کسب‌وکار، معماری نرم‌افزار، و منابع موجود دارد. اجرای صحیح این تکنیک‌ها نیازمند درک عمیقی از هر دو معماری و چگونگی به کارگیری این مفاهیم در هر یک است. با پیشرفت و تکامل مستمر در روش‌های توسعه نرم‌افزار و آزمون، توسعه‌دهندگان باید به دنبال یادگیری و بهبود مهارت‌های خود در این زمینه‌ها باشند تا بتوانند بهترین کیفیت را در تولیدات نرم‌افزاری خود ارائه دهند.