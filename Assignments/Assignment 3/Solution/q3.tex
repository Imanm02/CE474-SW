\section*{جواب سوال ۳}

جواب این سوال خیلی گسترده هستش، من سعی می‌کنم خیلی خلاصه و با بیان خلاصه‌ترین حالات، خواسته‌ی سوال را پیاده‌سازی کنم.

\section*{الگوهای تحلیل فاولر}

الگوهای تحلیل فاولر شامل هفت الگوی اصلی است:

\begin{itemize}
	\item \textbf{الگوی تک وظیفه \lr{(Single Responsibility Principle)}:} هر کلاس باید تنها یک مسئولیت مشخص را پوشش دهد.
	\item \textbf{الگوی بازتابیدگی \lr{(Open Closed Principle)}:} واحدهای نرم‌افزاری باید به گونه‌ای طراحی شوند که تغییرپذیر باشند ولی قابلیت اضافه شدن عملکرد جدید را داشته باشند.
	\item \textbf{الگوی جایگزینی لیسبرگ \lr{(Liskov Substitution Principle)}:} زیرکلاس‌ها باید در محل استفاده از کلاس‌های بالادستی خود جایگزین شوند بدون اینکه قابلیت‌های برنامه را تغییر دهند.
	\item \textbf{الگوی وابستگی خارجی \lr{(Dependency Inversion Principle)}:} واحدهای پایین‌تر باید وابسته به واحدهای سطح بالاتر باشند نه برعکس.
	\item \textbf{الگوی تقلیل تعداد وابستگی‌ها \lr{(Principle of Least Knowledge)}:} یک عنصر نباید از جزئیات پیچیده‌تر از آنچه ضروری است، آگاه باشد.
	\item \textbf{الگوی تقسیم مسئولیت \lr{(Principle of Seperation of Concerns)}:} جدا کردن مولفه‌هایی که تغییر می‌کنند از مولفه‌هایی که ثابت هستند.
	\item \textbf{الگوی تسطیح \lr{(Principle of Stable Dependencies)}:} وابستگی‌ها باید جهت مولفه‌های پایین‌تر باشند نه جهت مولفه‌های بالاتر.
\end{itemize}

این الگوها برای طراحی معماری سیستم‌های نرم‌افزاری قابل استفاده، تعمیرپذیر و تغییرپذیر مورد استفاده قرار می‌گیرند.

\section*{الگوهای طراحی غنی‌سازی یا \lr{Creational Patterns}}

در الگوهای طراحی گانگ اوف فاولر شامل:

\begin{itemize}
	\item \textbf{الگوی تکیه‌گاه سازنده \lr{(Factory Method)}:} تعریف یک واسط برای ساخت شیء، اما انتخاب نوع شیء را به زیرکلاسها واگذار می‌کند.
	\item \textbf{الگوی سازنده انتزاعی \lr{(Abstract Factory)}:} ارائه یک و
	اسط برای ساخت گروهی از شیءهای مرتبط بدون مشخص کردن کلاسهای خاص.
	\item \textbf{الگوی سازنده تک \lr{(Singleton)}:} تضمین ایجاد تنها یک نمونه از کلاس و دسترسی مرکزی به آن.
	\item \textbf{الگوی ساختارساز ساده \lr{(Builder)}:} جداسازی ساخت یک شیء پیچیده از تعریف آن.
	\item \textbf{الگوی نمونه‌سازی اولیه‌سازی \lr{(Prototype)}:} استفاده از یک نمونه برای ایجاد شیء جدید با همان مشخصات.
\end{itemize}

این الگوها مکانیسم‌های غنی‌سازی را فراهم می‌کنند تا بتوان شیءها را بدون توجه مستقیم به کلاس‌های آن‌ها خلق کرد. مزایایی همچون انعطاف‌پذیری، استفاده‌پذیری و تغییرپذیری را به ارمغان می‌آورند.

\section*{مقدمه}
در این سند، ما به بررسی نیازمندی‌های کلی سیستم مدیریت وظیفه می‌پردازیم و سپس چارچوب کلی برای تحلیل و طراحی را بر اساس الگوهای فاولر و GoF تعیین می‌کنیم.

\subsection*{تعریف برنامه‌های سیستم مدیریت وظیفه}

\subsubsection*{برنامه‌های مدیریت وظیفه (Plan)}

\begin{itemize}
	\item هر برنامه شامل مجموعه‌ای از کنش‌ها یا وظایف است که باید انجام شوند.
	\item برنامه‌ها می‌توانند به صورت مشترک از کنش‌های مشابه استفاده کنند.
	\item برنامه‌ها باید بتوانند کنش‌های پیش‌نیاز را تعریف کنند تا ترتیب انجام کارها را مشخص کنند.
\end{itemize}

\subsubsection*{کنش‌ها (Action)}

\begin{itemize}
	\item کنش‌ها می‌توانند در مراحل مختلفی باشند: پیشنهادی، تایید شده، در حال اجرا، یا انجام شده.
	\item کنش‌ها دارای وضعیت‌های مختلفی هستند که باید در رابط کاربری نمایش داده شوند.
\end{itemize}

\subsubsection*{کاربران (Users)}

\begin{itemize}
	\item کاربران می‌توانند به کنش‌ها تخصیص داده شوند.
	\item کاربران باید از تغییرات مربوط به کنش‌های تخصیص داده شده مطلع شوند.
\end{itemize}

\section*{تحلیل}

در مرحله تحلیل، از الگوهای برنامه‌ریزی فاولر برای تعریف روابط بین برنامه‌ها و کنش‌ها استفاده می‌کنیم.

\subsection*{الگوی سمت کنش‌ها}

\begin{itemize}
	\item این الگو توضیح می‌دهد که چگونه کنش‌ها می‌توانند به یک یا چند برنامه تخصیص داده شوند.
	\item باید برای هر کنش، وابستگی‌هایی به کنش‌های دیگر ایجاد کرد که به صورت پیش‌نیاز عمل می‌کنند، بنابراین ایجاد وضعیت‌های وابسته به یکدیگر ممکن است.
\end{itemize}

\subsection*{الگوی سمت برنامه‌ها}

\begin{itemize}
	\item این الگو تعیین می‌کند که چگونه برنامه‌ها می‌توانند چندین کنش را در خود جای دهند و چگونه این کنش‌ها می‌توانند به اهداف کلی برنامه کمک کنند.
	\item باید ساختاری طراحی کنیم که اجازه دهد برنامه‌ها به صورت موثر و کارآمد وظایف و کنش‌های مورد نیاز خود را مدیریت کنند.
\end{itemize}

\section*{طراحی با استفاده از الگوی پل و الگوی ناظر}

\subsection*{الگوی پل (Bridge)}

\begin{itemize}
	\item بخش‌هایی از رفتار کلاس کاربر که به تخصیص کنش‌ها مربوط می‌شوند، باید به کلاس‌های مجزا تقسیم شوند تا انعطاف‌پذیری و توسعه‌پذیری بیشتری داشته باشیم.
	\item این کار به ما اجازه می‌دهد که تغییرات را به راحتی و بدون نیاز به تغییر در کلاس‌های اصلی کاربر اعمال کنیم.
\end{itemize}

\subsection*{الگوی ناظر (Observer)}

\begin{itemize}
	\item از طریق الگوی ناظر، کلاس‌هایی که از الگوی پل پیروی می‌کنند باید بتوانند تغییرات در کنش‌ها را به کاربرانی که به آن کنش‌ها تخصیص داده شده‌اند، اطلاع‌رسانی کنند.
	\item این سیستم اطلاع‌رسانی باید به گونه‌ای باشد که کاربران بتوانند از تغییرات وضعیت و محتوای کنش‌ها به طور فوری مطلع شوند.
\end{itemize}

\subsection*{الگوی حالت (State)}

\begin{itemize}
	\item اگر رفتار کنش‌ها بسته به حالت‌های مختلفی که دارند تغییر کند، باید از الگوی حالت استفاده کنیم.
	\item این کمک می‌کند تا رفتار مرتبط با هر کنش را بر اساس وضعیت آن مدیریت کنیم.
\end{itemize}

در هر مرحله از تحلیل و طراحی، باید توجه داشته باشیم که تمام جزئیات بر اساس نیازمندی‌های تعریف شده و درک ما از سیستم مورد نظر باشد. باید توضیحات کافی برای توجیه تصمیمات طراحی ارائه دهیم و نشان دهیم که چگونه از الگوها برای رسیدن به راه حل‌های مسئله استفاده کرده‌ایم.